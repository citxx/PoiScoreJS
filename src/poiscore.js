/**
 * The MIT License (MIT)
 * Copyright (c) 2013 Artem Tabolin
 *  
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ======================================================================
 */

var PoiScore = (function() {
	function extend(former, latter) {
		var object = {};

		if (typeof former === "object") {
			for (var key in former) {
				if (former.hasOwnProperty(key)) {
					object[key] = former[key];
				}
			}
		}

		if (typeof latter === "object") {
			for (var key in latter) {
				if (latter.hasOwnProperty(key)) {
					object[key] = latter[key];
				}
			}
		}

		return object;
	};

	var API = {};

	defaultProps = {
		linesInDescriptionBox: 4,  // The number of lines occupied by description box. Zero if not wanted.
		commentBoxFraction: 0.25,  // Size of comment box in relation to body width. Zero if not wanted.
		cellsPerSubgroup: 4,       // Size of single subgroup in cells.
		subgroupsPerGroup: 2,      // Size of single group in subgroups.
		groupsPerLine: 4,          // Size of single line in groups.
		linesPerPage: 8,           // The number of lines in a single page.
		copyright: 'Copyright (C) 2013 Yuta Imamura, poicommunity.com',
		footnote: 'Generated by PoiScoreJS, https://github.com/citxx/PoiScoreJS'
	};

	API.properties = function(props) {
		return extend(defaultProps, props);
	};

	styles = {
		boldLine: {strokeWidth: 0.0013, strokeColor: [0, 0, 0]},
		thinLine: {strokeWidth: 0.00064, strokeColor: [0, 0, 0]},
		lightLine: {strokeWidth: 0.00043, strokeColor: [100, 100, 100]},
		brightLine: {strokeWidth: 0.00043, strokeColor: [175, 175, 175]},
		footerLogo: {font: 'helvetica', fontSize: 0.06, textColor: [140, 140, 140], textPosition: "tl"},
		footerComment: {font: 'helvetica', fontSize: 0.039, textColor: [100, 100, 100], textPosition: "tr"}
	};

	/** Generate PoiScore document of several pages. */
	API.gen = function(renderer, pages) {
		for (var i = 0; i < pages.length; i++) {
			var pageProps = pages[i];
			if (i > 0) {
				renderer.addPage();
			}
			this.addScore(renderer, pageProps, 0, 0, 1, 1);
		}
		return renderer;
	};

	/** Generate single-paged PoiScore document. */
	API.genPage = function(renderer, props) {
		return this.gen(renderer, [props]);
	};

	/** Fill current page with appropriate PoiScore page. */
	API.addScore = function(renderer, props, x, y, width, height) {
		this.addHeader(renderer, props, x, y, width, 0.06 * height);
		this.addBody(renderer, props, x, y + 0.07 * height, width, 0.885 * height);
		this.addFooter(renderer, props, x, y + 0.96 * height, width, 0.04 * height);
	};

	API.addHeader = function(renderer, props, x, y, width, height) {
		var firstY = y + height / 2.1;
		var secondY = y + 2 * height / 2.1;
		var lX = x + 2 * width / 3;
		var rX = x + 5 * width / 6;

		renderer.line(x, firstY, lX, firstY, styles.thinLine);
		renderer.line(x, secondY, lX, secondY, styles.thinLine);
		renderer.line(rX, secondY, x + width, secondY, styles.thinLine);
	};

	API.addFooter = function(renderer, props, x, y, width, height) {
		renderer.text("POISCORE", x, y, styles.footerLogo);

		var th = renderer.text(props.copyright, x + width, y, styles.footerComment)[1];
		renderer.text(props.footnote, x + width, y + th + 0.004, styles.footerComment);
	};

	API.addBody = function(renderer, props, x, y, width, height) {
		if (props.commentBoxFraction > 0) {
			var xpos = x + props.commentBoxFraction * width;
			this.addWorkspace(renderer, props, xpos, y, width - (xpos - x), height);
			renderer.line(xpos, y, xpos, y + height, styles.boldLine);
		}
		else {
			this.addWorkspace(renderer, props, x, y, width, height);
		}
		renderer.rect(x, y, width, height, styles.boldLine);
	};

	API.addWorkspace = function(renderer, props, x, y, width, height) {
		if (props.linesInDescriptionBox > 0) {
			var descHeight = height / props.linesPerPage * props.linesInDescriptionBox;
			var ypos = y + descHeight;
			var linesPerPage = props.linesPerPage - props.linesInDescriptionBox;
			this.addLines(
				renderer, props, linesPerPage,
				x, ypos, width, height - descHeight
			);
			renderer.line(x, ypos, x + width, ypos, styles.boldLine);
		}
		else {
			this.addLines(
				renderer, props, props.linesPerPage,
				x, y, width, height
			);
		}
	};

	API.addLines = function(renderer, props, number, x, y, width, height) {
		var lineHeight = height / number;
		for (var i = 0; i < number; i += 1) {
			var ypos = y + i * lineHeight;
			this.addLine(renderer, props, x, ypos, width, lineHeight);
			if (i != 0) {
				renderer.line(x, ypos, x + width, ypos, styles.thinLine);
			}
		}
	};

	API.addLine = function(renderer, props, x, y, width, height) {
		var topPos = y + 0.1 * height;
		var bottomPos = y + 0.9 * height;

		renderer.line(x, topPos, x + width, topPos, styles.brightLine);

		// Draw subgroup lines
		var subGroupsNumber = props.groupsPerLine * props.subgroupsPerGroup;
		var subGroupWidth = width / subGroupsNumber;
		for (var i = 1; i < subGroupsNumber; i++) {
			var subGroupX = x + i * subGroupWidth;
			renderer.line(subGroupX, y, subGroupX, y + height, styles.brightLine);
		}

		// Draw group lines
		var groupWidth = width / props.groupsPerLine;
		for (var i = 1; i < props.groupsPerLine; i++) {
			var groupX = x + i * groupWidth;
			renderer.line(groupX, y, groupX, y + height, styles.lightLine);
		}

		// Draw cells
		var cellsNumber =
			props.cellsPerSubgroup *
			props.subgroupsPerGroup *
			props.groupsPerLine;
		var cellWidth = width / cellsNumber;
		for (var i = 1; i < cellsNumber; i++) {
			var cellX = x + i * cellWidth;
			renderer.line(cellX, bottomPos, cellX, y + height, styles.thinLine);
		}

		renderer.line(x, bottomPos, x + width, bottomPos, styles.thinLine);
	};


	var black = [0, 0, 0];
	var Renderer = {
		defaultOptions : {
			strokeWidth: 0.0013,
			strokeColor: black,
			font: 'helvetica',
			fontSize: 0.051,
			textColor: black,
			textPosition: "tl"
		},

		extendOptions: function(options) {
			return extend(this.defaultOptions, options);
		}
	};

	API.jsPDFRenderer = function(doc, width, height, mLeft, mTop, mRight, mBottom) {
		if (typeof width === 'undefined') { // Default is A4
			this.mL = 20;
			this.mT = this.mR = this.mB = 10;
			this.w = 210 - (this.mL + this.mR);
			this.h = 297 - (this.mT + this.mB);
		}
		else {
			this.mL = mLeft;
			this.mT = mTop;
			this.mR = mRight;
			this.mB = mBottom;
			this.w = width - (this.mL + this.mR);
			this.h = height - (this.mT + this.mB);
		}

		this.k = Math.sqrt(this.w * this.w + this.h * this.h) / Math.sqrt(2);

		this.x = function(x) { return x * this.w + this.mL; }
		this.y = function(y) { return y * this.h + this.mT; }

		this.addPage = function() {
			doc.addPage();
		}

		this.setUp = function(options) {
			var opts = this.extendOptions(options);
			doc.setLineWidth(opts.strokeWidth * this.k);
			doc.setDrawColor(
				opts.strokeColor[0],
				opts.strokeColor[1],
				opts.strokeColor[2]
			);

			doc.setFont(opts.font);
			doc.setFontSize(Math.round(opts.fontSize * this.k));
			doc.setTextColor(
				opts.textColor[0],
				opts.textColor[1],
				opts.textColor[2]
			);

			return opts;
		};

		this.line = function(x1, y1, x2, y2, options) {
			this.setUp(options);
			doc.line(this.x(x1), this.y(y1), this.x(x2), this.y(y2));
			return [Math.abs(x1 - x2), Math.abs(y1 - y2)];
		};

		this.rect = function(x1, y1, width, height, options) {
			this.setUp(options);
			doc.rect(this.x(x1), this.y(y1), width * this.w, height * this.h);
			return [width, height];
		};

		this.text = function(text, x, y, options) {
			var opts = this.setUp(options);

			var pointsToMm = 25.6 / 72;
			var actualFontSize = Math.round(opts.fontSize * this.k);
			var textHeight = actualFontSize / this.h * pointsToMm;
			var textWidth = actualFontSize / this.w * doc.getStringUnitWidth(text) * pointsToMm;
			var mx, my;
			if (opts.textPosition[0] == 't') { my = y + textHeight; }
			else if(opts.textPosition[0] == 'b') { my = y; }
			if (opts.textPosition[1] == 'l') { mx = x; }
			   else if (opts.textPosition[1] == 'r') { mx = x - textWidth; }
			doc.text(text, this.x(mx), this.y(my));
			return [textWidth, textHeight];
		};

		return this;
	};
	API.jsPDFRenderer.prototype = Renderer;

	API.raphaelSVGRenderer = function(paper, width, height) {
		this.w = width;
		this.h = height;
		this.k = Math.sqrt(this.w * this.w + this.h * this.h) / Math.sqrt(2);

		this.x = function(x) { return x * this.w + 0.5; }
		this.y = function(y) { return y * this.h + 0.5; }

		this.hexRGB = function(rgb) { return Raphael.rgb(rgb[0], rgb[1], rgb[2]); }
		this.strokeWidth = function(w) { return Math.max(1, w * this.k); }

		this.addPage = function() {

		}

		this.line = function(x1, y1, x2, y2, options) {
			var opts = this.extendOptions(options);
			paper.path([
				'M', this.x(x1), ',', this.y(y1),
				'L', this.x(x2), ',', this.y(y2)
			].join('')).attr({
				'stroke': this.hexRGB(opts.strokeColor),
				'stroke-width': this.strokeWidth(opts.strokeWidth)
			});
			return [Math.abs(x1 - x2), Math.abs(y1 - y2)];
		};

		this.rect = function(x, y, width, height, options) {
			var opts = this.extendOptions(options);
			paper.rect(this.x(x), this.y(y), width * this.w, height * this.h).attr({
				'stroke': this.hexRGB(opts.strokeColor),
				'stroke-width': this.strokeWidth(opts.strokeWidth)
			});
		}

		this.text = function(text, x, y, options) {
			// var opts = this.extendOptions(options);
			// var textAnchor;
			// if (opts.textPosition[1] == 'l') { textAnchor = 'start'; }
			// else if (opts.textPosition[1] == 'r') { textAnchor = 'end'; }
			// var textSVG = paper.text(this.x(x), this.y(y), text).attr({
			//     'stroke': this.hexRGB(opts.strokeColor),
			//     'font': opts.font,
			//     'font-size': Math.round(opts.fontSize * this.k),
			//     'text-anchor': textAnchor
			// });
			return [0, 0];
		}

		return this;
	};
	API.raphaelSVGRenderer.prototype = Renderer;

	return API;
})();
